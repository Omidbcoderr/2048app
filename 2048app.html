<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #faf8ef;
            margin: 0;
            padding: 20px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden;
        }
        
        .container {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 40px;
            margin: 0;
            color: #776e65;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .score-container {
            background: #bbada0;
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            text-align: center;
        }
        
        .score-title {
            font-size: 14px;
        }
        
        .score-value {
            font-size: 20px;
        }
        
        .game-container {
            background: #bbada0;
            border-radius: 6px;
            width: 100%;
            height: 0;
            padding-bottom: 100%;
            position: relative;
            margin-bottom: 20px;
            touch-action: none;
            overflow: hidden;
        }
        
        .grid-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            padding: 10px;
            box-sizing: border-box;
        }
        
        .grid-cell {
            background: rgba(238, 228, 218, 0.35);
            border-radius: 3px;
        }
        
        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            font-weight: bold;
            border-radius: 3px;
            transition: all 0.15s ease-in-out;
            z-index: 10;
            box-sizing: border-box;
            will-change: transform;
        }
        
        .tile-new {
            animation: appear 0.15s ease-in-out;
        }
        
        .tile-merged {
            animation: pop 0.15s ease-in-out;
            z-index: 20;
        }
        
        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes pop {
            0% {
                transform: scale(0.9);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        
        .tile-2 {
            background: #eee4da;
            color: #776e65;
        }
        
        .tile-4 {
            background: #ede0c8;
            color: #776e65;
        }
        
        .tile-8 {
            background: #f2b179;
            color: white;
        }
        
        .tile-16 {
            background: #f59563;
            color: white;
        }
        
        .tile-32 {
            background: #f67c5f;
            color: white;
        }
        
        .tile-64 {
            background: #f65e3b;
            color: white;
        }
        
        .tile-128 {
            background: #edcf72;
            color: white;
            font-size: 25px;
        }
        
        .tile-256 {
            background: #edcc61;
            color: white;
            font-size: 25px;
        }
        
        .tile-512 {
            background: #edc850;
            color: white;
            font-size: 25px;
        }
        
        .tile-1024 {
            background: #edc53f;
            color: white;
            font-size: 20px;
        }
        
        .tile-2048 {
            background: #edc22e;
            color: white;
            font-size: 20px;
        }
        
        .game-message {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(238, 228, 218, 0.73);
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .game-message.game-won {
            background: rgba(237, 194, 46, 0.5);
        }
        
        .game-message.game-over {
            background: rgba(238, 228, 218, 0.73);
        }
        
        .game-message p {
            font-size: 60px;
            font-weight: bold;
            color: #776e65;
            margin: 0;
        }
        
        .game-message .lower {
            margin-top: 30px;
        }
        
        button {
            background: #8f7a66;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.15s ease-in-out;
        }
        
        button:hover {
            background: #9f8b77;
            transform: scale(1.05);
        }
        
        @media (max-width: 500px) {
            h1 {
                font-size: 30px;
            }
            
            .tile {
                font-size: 20px;
            }
            
            .tile-128, .tile-256, .tile-512 {
                font-size: 20px;
            }
            
            .tile-1024, .tile-2048 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>2048</h1>
            <div class="score-container">
                <div class="score-title">SCORE</div>
                <div class="score-value" id="score">0</div>
            </div>
        </div>
        
        <div class="game-container">
            <div class="grid-container" id="grid"></div>
            <div class="game-message" id="game-message">
                <p id="message-text"></p>
                <div class="lower">
                    <button id="keep-playing-button">Keep going</button>
                    <button id="retry-button">Try again</button>
                </div>
            </div>
        </div>
        
        <p>Join the numbers and get to the <strong>2048 tile!</strong></p>
        <p>Use arrow keys or swipe with your finger to move the tiles.</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('grid');
            const scoreDisplay = document.getElementById('score');
            const gameMessage = document.getElementById('game-message');
            const messageText = document.getElementById('message-text');
            const keepPlayingButton = document.getElementById('keep-playing-button');
            const retryButton = document.getElementById('retry-button');
            
            // Create grid cells
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridContainer.appendChild(cell);
            }
            
            let grid = [];
            let score = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;
            let gameOver = false;
            let won = false;
            let keepPlaying = false;
            let isMoving = false;
            
            // Initialize the game
            function initGame() {
                grid = Array(4).fill().map(() => Array(4).fill(0));
                score = 0;
                gameOver = false;
                won = false;
                keepPlaying = false;
                updateScore();
                clearTiles();
                addRandomTile();
                addRandomTile();
                hideMessage();
            }
            
            // Clear all tiles from the grid
            function clearTiles() {
                const tiles = document.querySelectorAll('.tile');
                tiles.forEach(tile => tile.remove());
            }
            
            // Add a random tile (2 or 4) to an empty cell
            function addRandomTile() {
                const emptyCells = [];
                
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (grid[row][col] === 0) {
                            emptyCells.push({ row, col });
                        }
                    }
                }
                
                if (emptyCells.length > 0) {
                    const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    grid[row][col] = Math.random() < 0.9 ? 2 : 4;
                    renderTile(row, col, grid[row][col], true);
                }
            }
            
            // Render a tile at the specified position
            function renderTile(row, col, value, isNew = false, isMerged = false) {
                const tile = document.createElement('div');
                tile.className = `tile tile-${value}`;
                tile.textContent = value;
                
                if (isNew) {
                    tile.classList.add('tile-new');
                }
                if (isMerged) {
                    tile.classList.add('tile-merged');
                }
                
                const cellSize = (gridContainer.clientWidth - 50) / 4;
                const x = col * (cellSize + 10) + 10;
                const y = row * (cellSize + 10) + 10;
                
                tile.style.width = `${cellSize}px`;
                tile.style.height = `${cellSize}px`;
                tile.style.left = `${x}px`;
                tile.style.top = `${y}px`;
                
                gridContainer.appendChild(tile);
                
                // Remove animation classes after animation completes
                if (isNew || isMerged) {
                    setTimeout(() => {
                        tile.classList.remove('tile-new', 'tile-merged');
                    }, 150);
                }
            }
            
            // Update the score display
            function updateScore() {
                scoreDisplay.textContent = score;
            }
            
            // Check if there are any moves available
            function canMove() {
                // Check for empty cells
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (grid[row][col] === 0) {
                            return true;
                        }
                    }
                }
                
                // Check for possible merges
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 3; col++) {
                        if (grid[row][col] === grid[row][col + 1]) {
                            return true;
                        }
                    }
                }
                
                for (let col = 0; col < 4; col++) {
                    for (let row = 0; row < 3; row++) {
                        if (grid[row][col] === grid[row + 1][col]) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Show game over or win message
            function showMessage(isWin) {
                if (isWin && !keepPlaying) {
                    messageText.textContent = 'You Win!';
                    gameMessage.classList.add('game-won');
                    gameMessage.classList.remove('game-over');
                    keepPlayingButton.style.display = 'block';
                    won = true;
                } else {
                    messageText.textContent = 'Game Over!';
                    gameMessage.classList.add('game-over');
                    gameMessage.classList.remove('game-won');
                    keepPlayingButton.style.display = 'none';
                    gameOver = true;
                }
                
                gameMessage.style.display = 'flex';
            }
            
            // Hide the message
            function hideMessage() {
                gameMessage.style.display = 'none';
            }
            
            // Move tiles in the specified direction
            function moveTiles(direction) {
                if (gameOver && !keepPlaying) return;
                if (isMoving) return;
                
                isMoving = true;
                
                let moved = false;
                const newGrid = Array(4).fill().map(() => Array(4).fill(0));
                const mergedTiles = Array(4).fill().map(() => Array(4).fill(false));
                
                // Process the grid based on direction
                if (direction === 'left') {
                    for (let row = 0; row < 4; row++) {
                        let newCol = 0;
                        let prevValue = null;
                        
                        for (let col = 0; col < 4; col++) {
                            if (grid[row][col] !== 0) {
                                if (prevValue === null) {
                                    prevValue = grid[row][col];
                                } else if (prevValue === grid[row][col]) {
                                    newGrid[row][newCol] = prevValue * 2;
                                    score += newGrid[row][newCol];
                                    prevValue = null;
                                    moved = true;
                                    mergedTiles[row][newCol] = true;
                                    newCol++;
                                } else {
                                    newGrid[row][newCol] = prevValue;
                                    prevValue = grid[row][col];
                                    newCol++;
                                }
                            }
                        }
                        
                        if (prevValue !== null) {
                            newGrid[row][newCol] = prevValue;
                            if (newCol !== 3 || (newCol === 3 && grid[row][3] !== prevValue)) {
                                moved = true;
                            }
                        }
                    }
                } else if (direction === 'right') {
                    for (let row = 0; row < 4; row++) {
                        let newCol = 3;
                        let prevValue = null;
                        
                        for (let col = 3; col >= 0; col--) {
                            if (grid[row][col] !== 0) {
                                if (prevValue === null) {
                                    prevValue = grid[row][col];
                                } else if (prevValue === grid[row][col]) {
                                    newGrid[row][newCol] = prevValue * 2;
                                    score += newGrid[row][newCol];
                                    prevValue = null;
                                    moved = true;
                                    mergedTiles[row][newCol] = true;
                                    newCol--;
                                } else {
                                    newGrid[row][newCol] = prevValue;
                                    prevValue = grid[row][col];
                                    newCol--;
                                }
                            }
                        }
                        
                        if (prevValue !== null) {
                            newGrid[row][newCol] = prevValue;
                            if (newCol !== 0 || (newCol === 0 && grid[row][0] !== prevValue)) {
                                moved = true;
                            }
                        }
                    }
                } else if (direction === 'up') {
                    for (let col = 0; col < 4; col++) {
                        let newRow = 0;
                        let prevValue = null;
                        
                        for (let row = 0; row < 4; row++) {
                            if (grid[row][col] !== 0) {
                                if (prevValue === null) {
                                    prevValue = grid[row][col];
                                } else if (prevValue === grid[row][col]) {
                                    newGrid[newRow][col] = prevValue * 2;
                                    score += newGrid[newRow][col];
                                    prevValue = null;
                                    moved = true;
                                    mergedTiles[newRow][col] = true;
                                    newRow++;
                                } else {
                                    newGrid[newRow][col] = prevValue;
                                    prevValue = grid[row][col];
                                    newRow++;
                                }
                            }
                        }
                        
                        if (prevValue !== null) {
                            newGrid[newRow][col] = prevValue;
                            if (newRow !== 3 || (newRow === 3 && grid[3][col] !== prevValue)) {
                                moved = true;
                            }
                        }
                    }
                } else if (direction === 'down') {
                    for (let col = 0; col < 4; col++) {
                        let newRow = 3;
                        let prevValue = null;
                        
                        for (let row = 3; row >= 0; row--) {
                            if (grid[row][col] !== 0) {
                                if (prevValue === null) {
                                    prevValue = grid[row][col];
                                } else if (prevValue === grid[row][col]) {
                                    newGrid[newRow][col] = prevValue * 2;
                                    score += newGrid[newRow][col];
                                    prevValue = null;
                                    moved = true;
                                    mergedTiles[newRow][col] = true;
                                    newRow--;
                                } else {
                                    newGrid[newRow][col] = prevValue;
                                    prevValue = grid[row][col];
                                    newRow--;
                                }
                            }
                        }
                        
                        if (prevValue !== null) {
                            newGrid[newRow][col] = prevValue;
                            if (newRow !== 0 || (newRow === 0 && grid[0][col] !== prevValue)) {
                                moved = true;
                            }
                        }
                    }
                }
                
                if (moved) {
                    // Animate the movement
                    animateMovement(grid, newGrid, mergedTiles, () => {
                        grid = newGrid;
                        updateScore();
                        addRandomTile();
                        
                        // Check for win
                        if (!won && !keepPlaying) {
                            for (let row = 0; row < 4; row++) {
                                for (let col = 0; col < 4; col++) {
                                    if (grid[row][col] === 2048) {
                                        showMessage(true);
                                        isMoving = false;
                                        return;
                                    }
                                }
                            }
                        }
                        
                        // Check for game over
                        if (!canMove()) {
                            showMessage(false);
                        }
                        
                        isMoving = false;
                    });
                } else {
                    isMoving = false;
                }
            }
            
            // Animate tile movements
            function animateMovement(oldGrid, newGrid, mergedTiles, callback) {
                clearTiles();
                
                // First render all tiles at their new positions (hidden)
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (newGrid[row][col] !== 0) {
                            renderTile(row, col, newGrid[row][col], false, mergedTiles[row][col]);
                        }
                    }
                }
                
                // Get all tiles we just rendered
                const tiles = document.querySelectorAll('.tile');
                
                // Temporarily hide them
                tiles.forEach(tile => {
                    tile.style.opacity = '0';
                });
                
                // Now render tiles at their old positions
                const tempTiles = [];
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (oldGrid[row][col] !== 0) {
                            const tile = document.createElement('div');
                            tile.className = `tile tile-${oldGrid[row][col]}`;
                            tile.textContent = oldGrid[row][col];
                            
                            const cellSize = (gridContainer.clientWidth - 50) / 4;
                            const x = col * (cellSize + 10) + 10;
                            const y = row * (cellSize + 10) + 10;
                            
                            tile.style.width = `${cellSize}px`;
                            tile.style.height = `${cellSize}px`;
                            tile.style.left = `${x}px`;
                            tile.style.top = `${y}px`;
                            tile.style.zIndex = '15'; // Above new tiles but below merged tiles
                            
                            gridContainer.appendChild(tile);
                            tempTiles.push(tile);
                        }
                    }
                }
                
                // After a short delay, animate the movement
                setTimeout(() => {
                    // Show the new tiles
                    tiles.forEach(tile => {
                        tile.style.opacity = '1';
                    });
                    
                    // Animate old tiles to new positions
                    tempTiles.forEach(tile => {
                        // Find where this tile moved to
                        let found = false;
                        for (let newRow = 0; newRow < 4 && !found; newRow++) {
                            for (let newCol = 0; newCol < 4 && !found; newCol++) {
                                if (newGrid[newRow][newCol] === parseInt(tile.textContent) || 
                                    (mergedTiles[newRow][newCol] && newGrid[newRow][newCol] === parseInt(tile.textContent) * 2)) {
                                    
                                    const cellSize = (gridContainer.clientWidth - 50) / 4;
                                    const newX = newCol * (cellSize + 10) + 10;
                                    const newY = newRow * (cellSize + 10) + 10;
                                    
                                    tile.style.left = `${newX}px`;
                                    tile.style.top = `${newY}px`;
                                    
                                    if (mergedTiles[newRow][newCol] && newGrid[newRow][newCol] === parseInt(tile.textContent) * 2) {
                                        // This tile is being merged
                                        setTimeout(() => {
                                            tile.remove();
                                        }, 150);
                                    } else {
                                        // Just moving
                                        setTimeout(() => {
                                            tile.remove();
                                        }, 150);
                                    }
                                    
                                    found = true;
                                }
                            }
                        }
                        
                        if (!found) {
                            // Tile disappeared (shouldn't happen in 2048)
                            tile.remove();
                        }
                    });
                    
                    // Execute callback after animations complete
                    setTimeout(callback, 150);
                }, 10);
            }
            
            // Handle keyboard events
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') {
                    moveTiles('left');
                } else if (e.key === 'ArrowRight') {
                    moveTiles('right');
                } else if (e.key === 'ArrowUp') {
                    moveTiles('up');
                } else if (e.key === 'ArrowDown') {
                    moveTiles('down');
                }
            });
            
            // Handle touch events for swipe detection
            gridContainer.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: false });
            
            gridContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            gridContainer.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].clientX;
                touchEndY = e.changedTouches[0].clientY;
                handleSwipe();
            }, { passive: false });
            
            // Determine swipe direction
            function handleSwipe() {
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 50) {
                        moveTiles('right');
                    } else if (dx < -50) {
                        moveTiles('left');
                    }
                } else {
                    if (dy > 50) {
                        moveTiles('down');
                    } else if (dy < -50) {
                        moveTiles('up');
                    }
                }
            }
            
            // Button event listeners
            keepPlayingButton.addEventListener('click', () => {
                keepPlaying = true;
                hideMessage();
            });
            
            retryButton.addEventListener('click', initGame);
            
            // Start the game
            initGame();
        });
    </script>
</body>
</html>